/*
 * This file was generated by the scsynth tool, and is available for use under
 * the MIT license. More information can be found at
 * https://github.com/arminalaghi/scsynth/
 */
module stochWrapper( //handles stochastic/binary conversion for ReSC
	input [7:0] pixel_1_bin,
	input [7:0] pixel_2_bin,
	input [7:0] pixel_3_bin,
	input [7:0] pixel_4_bin,
	input [7:0] pixel_6_bin,
	input [7:0] pixel_7_bin,
	input [7:0] pixel_8_bin,
	input [7:0] pixel_9_bin,
	input start, //signal to start counting
	output reg done, //signal that a number has been computed
	output reg [7:0] z_bin, //binary value of output

	input clk,
	input reset
);
	wire z1_1_stoch;
	wire z2_1_stoch;
	wire z3_1_stoch;
	wire z4_1_stoch;
	wire z6_1_stoch;
	wire z7_1_stoch;
	wire z8_1_stoch;
	wire z9_1_stoch;
	wire z1_2_stoch;
	wire z2_2_stoch;
	wire z3_2_stoch;
	wire z4_2_stoch;
	wire z6_2_stoch;
	wire z7_2_stoch;
	wire z8_2_stoch;
	wire z9_2_stoch;

	wire r0_stoch;
	wire r1_stoch;
	wire r2_stoch;
	wire r3_stoch;
	wire r4_stoch;

	wire z_stoch;
	wire init;
	wire running;

	//RNGs and binary->stochastic conversion
	//Some level of correlation has to be granted based on stochFunction
	//5 RNGs for constants
	/*
	wire [15:0] randr0;
	wire [15:0] randr1;
	wire [15:0] randr2;
	wire [15:0] randr3;
	wire [15:0] randr4;

	stochLFSR16bit rand_gen_r0 (.seed (16'b1001100110011001),.data (randr0),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r1 (.seed (16'b1111000011110000),.data (randr1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r2 (.seed (16'b1010010110100101),.data (randr2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r3 (.seed (16'b1100001111000011),.data (randr3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r4 (.seed (16'b1001011010010110),.data (randr4),.enable (running),.restart (init),.clk (clk),.reset (reset));
	*/
	// 8 RNGs for pixels
	/*
	wire [15:0] rand1;
	wire [15:0] rand2;
	wire [15:0] rand3;
	wire [15:0] rand4;
	wire [15:0] rand5;
	wire [15:0] rand6;
	wire [15:0] rand7;
	wire [15:0] rand8;

	stochLFSR16bit rand_gen_1 (.seed (16'b0001001111010001),.data (rand1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_2 (.seed (16'b1110110100101110),.data (rand2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_3 (.seed (16'b0011011010101111),.data (rand3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_4 (.seed (16'b0010010100000111),.data (rand4),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_5 (.seed (16'b0100110110011001),.data (rand5),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_6 (.seed (16'b1011001011000111),.data (rand6),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_7 (.seed (16'b1110011001110100),.data (rand7),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_8 (.seed (16'b0011110011100000),.data (rand8),.enable (running),.restart (init),.clk (clk),.reset (reset));
	*/

	//5 RNGs for constants
	wire [7:0] randr0;
	wire [7:0] randr1;
	wire [7:0] randr2;
	wire [7:0] randr3;
	wire [7:0] randr4;

	stochLFSR8bit rand_gen_r0 (.seed (8'b10011001),.data (randr0),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r1 (.seed (8'b11110000),.data (randr1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r2 (.seed (8'b10100101),.data (randr2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r3 (.seed (8'b11000011),.data (randr3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r4 (.seed (8'b10010110),.data (randr4),.enable (running),.restart (init),.clk (clk),.reset (reset));

	// 8 RNGs for pixels
	wire [7:0] rand1;
	wire [7:0] rand2;
	wire [7:0] rand3;
	wire [7:0] rand4;
	wire [7:0] rand5;
	wire [7:0] rand6;
	wire [7:0] rand7;
	wire [7:0] rand8;

	stochLFSR8bit rand_gen_1 (.seed (8'b00010011),.data (rand1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_2 (.seed (8'b11101101),.data (rand2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_3 (.seed (8'b00110110),.data (rand3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_4 (.seed (8'b00100101),.data (rand4),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_5 (.seed (8'b01001101),.data (rand5),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_6 (.seed (8'b10110010),.data (rand6),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_7 (.seed (8'b11100110),.data (rand7),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_8 (.seed (8'b00111100),.data (rand8),.enable (running),.restart (init),.clk (clk),.reset (reset));

	//SNG using simple comparator
	assign r0_stoch = randr0[7:0] < 8'd127;
	assign r1_stoch = randr1[7:0] < 8'd127;
	assign r2_stoch = randr2[7:0] < 8'd127;
	assign r3_stoch = randr3[7:0] < 8'd127;
	assign r4_stoch = randr4[7:0] < 8'd127;
	//Mux1
	assign z1_1_stoch = rand1[7:0] < pixel_1_bin;
	assign z2_1_stoch = rand2[7:0] < pixel_2_bin;
	assign z2_2_stoch = rand3[7:0] < pixel_2_bin;
	assign z3_1_stoch = rand4[7:0] < pixel_3_bin;
	//Mux2
	assign z7_1_stoch = rand1[7:0] < pixel_7_bin;
	assign z8_1_stoch = rand2[7:0] < pixel_8_bin;
	assign z8_2_stoch = rand3[7:0] < pixel_8_bin;
	assign z9_1_stoch = rand4[7:0] < pixel_9_bin;

	//Mux3
	assign z1_2_stoch = rand5[7:0] < pixel_1_bin;
	assign z4_1_stoch = rand6[7:0] < pixel_4_bin;
	assign z4_2_stoch = rand7[7:0] < pixel_4_bin;
	assign z7_2_stoch = rand8[7:0] < pixel_7_bin;
	//Mux4
	assign z3_2_stoch = rand5[7:0] < pixel_3_bin;
	assign z6_1_stoch = rand6[7:0] < pixel_6_bin;
	assign z6_2_stoch = rand7[7:0] < pixel_6_bin;
	assign z9_2_stoch = rand8[7:0] < pixel_9_bin;

	stochFunction SF (
		.z1_1 (z1_1_stoch),
		.z2_1 (z2_1_stoch),
		.z3_1 (z3_1_stoch),
		.z4_1 (z4_1_stoch),
		.z6_1 (z6_1_stoch),
		.z7_1 (z7_1_stoch),
		.z8_1 (z8_1_stoch),
		.z9_1 (z9_1_stoch),
		.z1_2 (z1_2_stoch),
		.z2_2 (z2_2_stoch),
		.z3_2 (z3_2_stoch),
		.z4_2 (z4_2_stoch),
		.z6_2 (z6_2_stoch),
		.z7_2 (z7_2_stoch),
		.z8_2 (z8_2_stoch),
		.z9_2 (z9_2_stoch),
		.r0 (r0_stoch),
		.r1 (r1_stoch),
		.r2 (r2_stoch),
		.r3 (r3_stoch),
		.r4 (r4_stoch),
		.z (z_stoch)
	);

	reg [7:0] count; //count clock cycles
	wire [7:0] neg_one;
	assign neg_one = -1;

	//Finite state machine. States:
	//0: finished, in need of resetting
	//1: initialized, start counting when start signal falls
	//2: running
	reg [1:0] cs; //current FSM state
	reg [1:0] ns; //next FSM state
	assign init = cs == 1;
	assign running = cs == 2;

	always @(posedge clk or posedge reset) begin
		if (reset) cs <= 0;
		else begin
			cs <= ns;
			if (running) begin
				if (count == neg_one) done <= 1;
				count <= count + 1;
				z_bin <= z_bin + z_stoch;
			end
		end
	end

	always @(*) begin
		case (cs)
			0: if (start) ns = 1; else ns = 0;
			1: if (start) ns = 1; else ns = 2;
			2: if (done) ns = 0; else ns = 2;
			default ns = 0;
		endcase
	end

	always @(posedge init) begin
		count <= 0;
		z_bin <= 0;
		done <= 0;
	end
endmodule
