/*
 * This file was generated by the scsynth tool, and is available for use under
 * the MIT license. More information can be found at
 * https://github.com/arminalaghi/scsynth/
 */
module stochWrapper( //handles stochastic/binary conversion for ReSC
	input [7:0] pixel_1_bin,
	input [7:0] pixel_2_bin,
	input [7:0] pixel_3_bin,
	input [7:0] pixel_4_bin,
	input [7:0] pixel_6_bin,
	input [7:0] pixel_7_bin,
	input [7:0] pixel_8_bin,
	input [7:0] pixel_9_bin,
	input start, //signal to start counting
	output reg done, //signal that a number has been computed
	output reg [7:0] z_bin, //binary value of output

	input clk,
	input reset
);
	wire z1_1_stoch;
	wire z2_1_stoch;
	wire z3_1_stoch;
	wire z4_1_stoch;
	wire z6_1_stoch;
	wire z7_1_stoch;
	wire z8_1_stoch;
	wire z9_1_stoch;
	wire z1_2_stoch;
	wire z2_2_stoch;
	wire z3_2_stoch;
	wire z4_2_stoch;
	wire z6_2_stoch;
	wire z7_2_stoch;
	wire z8_2_stoch;
	wire z9_2_stoch;

	wire r0_stoch;
	wire r1_stoch;
	wire r2_stoch;
	wire r3_stoch;
	wire r4_stoch;

	wire z_stoch;
	wire init;
	wire running;

	//RNGs and binary->stochastic conversion
	//Some level of correlation has to be granted based on stochFunction
	//5 RNGs for constants
	/*
	wire [15:0] randr0;
	wire [15:0] randr1;
	wire [15:0] randr2;
	wire [15:0] randr3;
	wire [15:0] randr4;

	stochLFSR16bit rand_gen_r0 (.seed (16'b1001100110011001),.data (randr0),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r1 (.seed (16'b1111000011110000),.data (randr1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r2 (.seed (16'b1010010110100101),.data (randr2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r3 (.seed (16'b1100001111000011),.data (randr3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_r4 (.seed (16'b1001011010010110),.data (randr4),.enable (running),.restart (init),.clk (clk),.reset (reset));
	*/
	// 8 RNGs for pixels
	/*
	wire [15:0] rand1;
	wire [15:0] rand2;
	wire [15:0] rand3;
	wire [15:0] rand4;
	wire [15:0] rand5;
	wire [15:0] rand6;
	wire [15:0] rand7;
	wire [15:0] rand8;

	stochLFSR16bit rand_gen_1 (.seed (16'b0001001111010001),.data (rand1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_2 (.seed (16'b1110110100101110),.data (rand2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_3 (.seed (16'b0011011010101111),.data (rand3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_4 (.seed (16'b0010010100000111),.data (rand4),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_5 (.seed (16'b0100110110011001),.data (rand5),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_6 (.seed (16'b1011001011000111),.data (rand6),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_7 (.seed (16'b1110011001110100),.data (rand7),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR16bit rand_gen_8 (.seed (16'b0011110011100000),.data (rand8),.enable (running),.restart (init),.clk (clk),.reset (reset));
	*/

	//5 RNGs for constants
	wire [7:0] randr0;
	wire [7:0] randr1;
	wire [7:0] randr2;
	wire [7:0] randr3;
	wire [7:0] randr4;

	stochLFSR8bit rand_gen_r0 (.seed (8'b10011001),.data (randr0),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r1 (.seed (8'b11110000),.data (randr1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r2 (.seed (8'b10100101),.data (randr2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r3 (.seed (8'b11000011),.data (randr3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_r4 (.seed (8'b10010110),.data (randr4),.enable (running),.restart (init),.clk (clk),.reset (reset));

	// 8 RNGs for pixels
	wire [7:0] rand1;
	wire [7:0] rand2;
	wire [7:0] rand3;
	wire [7:0] rand4;
	wire [7:0] rand5;
	wire [7:0] rand6;
	wire [7:0] rand7;
	wire [7:0] rand8;

	stochLFSR8bit rand_gen_1 (.seed (8'b00010011),.data (rand1),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_2 (.seed (8'b11101101),.data (rand2),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_3 (.seed (8'b00110110),.data (rand3),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_4 (.seed (8'b00100101),.data (rand4),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_5 (.seed (8'b01001101),.data (rand5),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_6 (.seed (8'b10110010),.data (rand6),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_7 (.seed (8'b11100110),.data (rand7),.enable (running),.restart (init),.clk (clk),.reset (reset));
	stochLFSR8bit rand_gen_8 (.seed (8'b00111100),.data (rand8),.enable (running),.restart (init),.clk (clk),.reset (reset));

	//SNG using simple comparator
	assign r0_stoch = 8'd127 > randr0[7:0];
	assign r1_stoch = 8'd127 > randr1[7:0];
	assign r2_stoch = 8'd127 > randr2[7:0];
	assign r3_stoch = 8'd127 > randr3[7:0];
	assign r4_stoch = 8'd127 > randr4[7:0];
	//Mux1
	assign z1_1_stoch = pixel_1_bin > rand1[7:0];
	assign z2_1_stoch = pixel_2_bin > rand2[7:0];
	assign z2_2_stoch = pixel_2_bin > rand3[7:0];
	assign z3_1_stoch = pixel_3_bin > rand4[7:0];
	//Mux2
	assign z7_1_stoch = pixel_7_bin > rand1[7:0];
	assign z8_1_stoch = pixel_8_bin > rand2[7:0];
	assign z8_2_stoch = pixel_8_bin > rand3[7:0];
	assign z9_1_stoch = pixel_9_bin > rand4[7:0];

	//Mux3
	assign z1_2_stoch = pixel_1_bin > rand5[7:0];
	assign z4_1_stoch = pixel_4_bin > rand6[7:0];
	assign z4_2_stoch = pixel_4_bin > rand7[7:0];
	assign z7_2_stoch = pixel_7_bin > rand8[7:0];
	//Mux4
	assign z3_2_stoch = pixel_3_bin > rand5[7:0];
	assign z6_1_stoch = pixel_6_bin > rand6[7:0];
	assign z6_2_stoch = pixel_6_bin > rand7[7:0];
	assign z9_2_stoch = pixel_9_bin > rand8[7:0];

	stochFunction SF (
		.z1_1 (z1_1_stoch),
		.z2_1 (z2_1_stoch),
		.z3_1 (z3_1_stoch),
		.z4_1 (z4_1_stoch),
		.z6_1 (z6_1_stoch),
		.z7_1 (z7_1_stoch),
		.z8_1 (z8_1_stoch),
		.z9_1 (z9_1_stoch),
		.z1_2 (z1_2_stoch),
		.z2_2 (z2_2_stoch),
		.z3_2 (z3_2_stoch),
		.z4_2 (z4_2_stoch),
		.z6_2 (z6_2_stoch),
		.z7_2 (z7_2_stoch),
		.z8_2 (z8_2_stoch),
		.z9_2 (z9_2_stoch),
		.r0 (r0_stoch),
		.r1 (r1_stoch),
		.r2 (r2_stoch),
		.r3 (r3_stoch),
		.r4 (r4_stoch),
		.z (z_stoch)
	);

	reg [7:0] count; //count clock cycles
	wire [7:0] neg_one;
	assign neg_one = -1;

	//Finite state machine. States:
	//0: finished, in need of resetting
	//1: initialized, start counting when start signal falls
	//2: running
	reg [1:0] cs; //current FSM state
	reg [1:0] ns; //next FSM state
	parameter IDLES = 2'b00;
	parameter INITS = 2'b01;
	parameter RUNNINGS = 2'b10;
	assign init = (cs==INITS);
	assign running = (cs==RUNNINGS);

//current state -> next state
	always @(posedge clk or posedge reset) begin
		if (reset) begin
			cs <=0;
		end
		else begin
			cs <=ns;
		end
	end

//Output logic
	always @(posedge clk or posedge reset) begin
		if (reset) begin
			count <= 0;
			z_bin <= 0;
			done <= 0;
		end
		else if (init) begin
			count <= 0;
			z_bin <= 0;
			done <= 0;
		end
		else begin
			if (running) begin
				done <= (1 & (count==neg_one));
				count <= count + 1;
				z_bin <= z_bin + z_stoch;
			end
		end
	end
// Next-state logic
	always @(*) begin
		case (cs)
			IDLES: begin
					if (start) begin
						ns = INITS;
					end 
					else begin
						ns = IDLES;
					end
			end
			INITS: begin 
					if (start) begin 
						ns = INITS;
					end 
					else begin
						ns = RUNNINGS;
					end
			end
			RUNNINGS: begin
					if (done) begin 
						ns = IDLES;
					end
					else begin
						ns = RUNNINGS;
					end
			end
			default ns = IDLES;
		endcase
	end

endmodule
