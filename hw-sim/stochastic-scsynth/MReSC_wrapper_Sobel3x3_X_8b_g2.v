/*
 * This file was generated by the scsynth tool, and is available for use under
 * the MIT license. More information can be found at
 * https://github.com/arminalaghi/scsynth/
 */
module MReSC_wrapper_Sobel3x3_X_8b_g2( //handles stochastic/binary conversion for ReSC
	input [7:0] x_1_bin, //binary value of input 1
	input [7:0] x_2_bin, //binary value of input 2
	input [7:0] x_3_bin, //binary value of input 3
	input [7:0] x_4_bin, //binary value of input 4
	input [7:0] x_5_bin, //binary value of input 5
	input [7:0] x_6_bin, //binary value of input 6
	input start, //signal to start counting
	output reg done, //signal that a number has been computed
	output reg [7:0] z_bin, //binary value of output

	input clk,
	input reset
);

	//the weights of the Bernstein polynomial
	reg [7:0] w0_bin = 8'd128;
	reg [7:0] w1_bin = 8'd81;
	reg [7:0] w2_bin = 8'd4;
	reg [7:0] w3_bin = 8'd0;
	reg [7:0] w4_bin = 8'd81;
	reg [7:0] w5_bin = 8'd0;
	reg [7:0] w6_bin = 8'd0;
	reg [7:0] w7_bin = 8'd0;
	reg [7:0] w8_bin = 8'd175;
	reg [7:0] w9_bin = 8'd128;
	reg [7:0] w10_bin = 8'd103;
	reg [7:0] w11_bin = 8'd4;
	reg [7:0] w12_bin = 8'd128;
	reg [7:0] w13_bin = 8'd81;
	reg [7:0] w14_bin = 8'd4;
	reg [7:0] w15_bin = 8'd0;
	reg [7:0] w16_bin = 8'd252;
	reg [7:0] w17_bin = 8'd153;
	reg [7:0] w18_bin = 8'd128;
	reg [7:0] w19_bin = 8'd81;
	reg [7:0] w20_bin = 8'd153;
	reg [7:0] w21_bin = 8'd157;
	reg [7:0] w22_bin = 8'd81;
	reg [7:0] w23_bin = 8'd0;
	reg [7:0] w24_bin = 8'd255;
	reg [7:0] w25_bin = 8'd252;
	reg [7:0] w26_bin = 8'd175;
	reg [7:0] w27_bin = 8'd128;
	reg [7:0] w28_bin = 8'd252;
	reg [7:0] w29_bin = 8'd153;
	reg [7:0] w30_bin = 8'd128;
	reg [7:0] w31_bin = 8'd81;
	reg [7:0] w32_bin = 8'd175;
	reg [7:0] w33_bin = 8'd128;
	reg [7:0] w34_bin = 8'd103;
	reg [7:0] w35_bin = 8'd4;
	reg [7:0] w36_bin = 8'd128;
	reg [7:0] w37_bin = 8'd81;
	reg [7:0] w38_bin = 8'd4;
	reg [7:0] w39_bin = 8'd0;
	reg [7:0] w40_bin = 8'd255;
	reg [7:0] w41_bin = 8'd175;
	reg [7:0] w42_bin = 8'd99;
	reg [7:0] w43_bin = 8'd103;
	reg [7:0] w44_bin = 8'd175;
	reg [7:0] w45_bin = 8'd128;
	reg [7:0] w46_bin = 8'd103;
	reg [7:0] w47_bin = 8'd4;
	reg [7:0] w48_bin = 8'd255;
	reg [7:0] w49_bin = 8'd252;
	reg [7:0] w50_bin = 8'd175;
	reg [7:0] w51_bin = 8'd128;
	reg [7:0] w52_bin = 8'd252;
	reg [7:0] w53_bin = 8'd153;
	reg [7:0] w54_bin = 8'd128;
	reg [7:0] w55_bin = 8'd81;
	reg [7:0] w56_bin = 8'd255;
	reg [7:0] w57_bin = 8'd255;
	reg [7:0] w58_bin = 8'd255;
	reg [7:0] w59_bin = 8'd175;
	reg [7:0] w60_bin = 8'd255;
	reg [7:0] w61_bin = 8'd252;
	reg [7:0] w62_bin = 8'd175;
	reg [7:0] w63_bin = 8'd128;

	wire [0:0] x_1_stoch;

	wire [0:0] x_2_stoch;

	wire [0:0] x_3_stoch;

	wire [0:0] x_4_stoch;

	wire [0:0] x_5_stoch;

	wire [0:0] x_6_stoch;
	wire [63:0] w_stoch;
	wire z_stoch;
	wire init;
	wire running;

	//RNGs for binary->stochastic conversion
	wire [7:0] randx_1_0;
	LFSR_8_bit_added_zero_Sobel3x3_X_8b_g2 rand_gen_x_1_0 (
		.seed (8'd5),
		.data (randx_1_0),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	assign x_1_stoch[0] = randx_1_0 < x_1_bin;

	wire [7:0] randx_2_0;
	LFSR_8_bit_added_zero_Sobel3x3_X_8b_g2 rand_gen_x_2_0 (
		.seed (8'd11),
		.data (randx_2_0),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	assign x_2_stoch[0] = randx_2_0 < x_2_bin;

	wire [7:0] randx_3_0;
	LFSR_8_bit_added_zero_Sobel3x3_X_8b_g2 rand_gen_x_3_0 (
		.seed (8'd17),
		.data (randx_3_0),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	assign x_3_stoch[0] = randx_3_0 < x_3_bin;

	wire [7:0] randx_4_0;
	LFSR_8_bit_added_zero_Sobel3x3_X_8b_g2 rand_gen_x_4_0 (
		.seed (8'd23),
		.data (randx_4_0),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	assign x_4_stoch[0] = randx_4_0 < x_4_bin;

	wire [7:0] randx_5_0;
	LFSR_8_bit_added_zero_Sobel3x3_X_8b_g2 rand_gen_x_5_0 (
		.seed (8'd29),
		.data (randx_5_0),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	assign x_5_stoch[0] = randx_5_0 < x_5_bin;

	wire [7:0] randx_6_0;
	LFSR_8_bit_added_zero_Sobel3x3_X_8b_g2 rand_gen_x_6_0 (
		.seed (8'd41),
		.data (randx_6_0),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	assign x_6_stoch[0] = randx_6_0 < x_6_bin;

	wire [7:0] randw;
	LFSR_8_bit_added_zero_Sobel3x3_X_8b_g2 rand_gen_w (
		.seed (8'd171),
		.data (randw),
		.enable (running),
		.restart (init),
		.clk (clk),
		.reset (reset)
	);
	assign w_stoch[0] = randw < w0_bin;

	assign w_stoch[1] = randw < w1_bin;

	assign w_stoch[2] = randw < w2_bin;

	assign w_stoch[3] = randw < w3_bin;

	assign w_stoch[4] = randw < w4_bin;

	assign w_stoch[5] = randw < w5_bin;

	assign w_stoch[6] = randw < w6_bin;

	assign w_stoch[7] = randw < w7_bin;

	assign w_stoch[8] = randw < w8_bin;

	assign w_stoch[9] = randw < w9_bin;

	assign w_stoch[10] = randw < w10_bin;

	assign w_stoch[11] = randw < w11_bin;

	assign w_stoch[12] = randw < w12_bin;

	assign w_stoch[13] = randw < w13_bin;

	assign w_stoch[14] = randw < w14_bin;

	assign w_stoch[15] = randw < w15_bin;

	assign w_stoch[16] = randw < w16_bin;

	assign w_stoch[17] = randw < w17_bin;

	assign w_stoch[18] = randw < w18_bin;

	assign w_stoch[19] = randw < w19_bin;

	assign w_stoch[20] = randw < w20_bin;

	assign w_stoch[21] = randw < w21_bin;

	assign w_stoch[22] = randw < w22_bin;

	assign w_stoch[23] = randw < w23_bin;

	assign w_stoch[24] = randw < w24_bin;

	assign w_stoch[25] = randw < w25_bin;

	assign w_stoch[26] = randw < w26_bin;

	assign w_stoch[27] = randw < w27_bin;

	assign w_stoch[28] = randw < w28_bin;

	assign w_stoch[29] = randw < w29_bin;

	assign w_stoch[30] = randw < w30_bin;

	assign w_stoch[31] = randw < w31_bin;

	assign w_stoch[32] = randw < w32_bin;

	assign w_stoch[33] = randw < w33_bin;

	assign w_stoch[34] = randw < w34_bin;

	assign w_stoch[35] = randw < w35_bin;

	assign w_stoch[36] = randw < w36_bin;

	assign w_stoch[37] = randw < w37_bin;

	assign w_stoch[38] = randw < w38_bin;

	assign w_stoch[39] = randw < w39_bin;

	assign w_stoch[40] = randw < w40_bin;

	assign w_stoch[41] = randw < w41_bin;

	assign w_stoch[42] = randw < w42_bin;

	assign w_stoch[43] = randw < w43_bin;

	assign w_stoch[44] = randw < w44_bin;

	assign w_stoch[45] = randw < w45_bin;

	assign w_stoch[46] = randw < w46_bin;

	assign w_stoch[47] = randw < w47_bin;

	assign w_stoch[48] = randw < w48_bin;

	assign w_stoch[49] = randw < w49_bin;

	assign w_stoch[50] = randw < w50_bin;

	assign w_stoch[51] = randw < w51_bin;

	assign w_stoch[52] = randw < w52_bin;

	assign w_stoch[53] = randw < w53_bin;

	assign w_stoch[54] = randw < w54_bin;

	assign w_stoch[55] = randw < w55_bin;

	assign w_stoch[56] = randw < w56_bin;

	assign w_stoch[57] = randw < w57_bin;

	assign w_stoch[58] = randw < w58_bin;

	assign w_stoch[59] = randw < w59_bin;

	assign w_stoch[60] = randw < w60_bin;

	assign w_stoch[61] = randw < w61_bin;

	assign w_stoch[62] = randw < w62_bin;

	assign w_stoch[63] = randw < w63_bin;

	MReSC_Sobel3x3_X_8b_g2 ReSC (
		.x_1 (x_1_stoch),
		.x_2 (x_2_stoch),
		.x_3 (x_3_stoch),
		.x_4 (x_4_stoch),
		.x_5 (x_5_stoch),
		.x_6 (x_6_stoch),
		.w (w_stoch),
		.z (z_stoch)
	);

	reg [7:0] count; //count clock cycles
	wire [7:0] neg_one;
	assign neg_one = -1;

	//Finite state machine. States:
	//0: finished, in need of resetting
	//1: initialized, start counting when start signal falls
	//2: running
	reg [1:0] cs; //current FSM state
	reg [1:0] ns; //next FSM state
	assign init = cs == 1;
	assign running = cs == 2;

	always @(posedge clk or posedge reset) begin
		if (reset) cs <= 0;
		else begin
			cs <= ns;
			if (running) begin
				if (count == neg_one) done <= 1;
				count <= count + 1;
				z_bin <= z_bin + z_stoch;
			end
		end
	end

	always @(*) begin
		case (cs)
			0: if (start) ns = 1; else ns = 0;
			1: if (start) ns = 1; else ns = 2;
			2: if (done) ns = 0; else ns = 2;
			default ns = 0;
		endcase
	end

	always @(posedge init) begin
		count <= 0;
		z_bin <= 0;
		done <= 0;
	end
endmodule
